[
    {
        "id": "example_action_template_filter",
        "user_id": "06dbe545-cdc6-43ea-bec6-16d732ad95d7",
        "name": "example action template filter",
        "type": "action",
        "content": "\"\"\"\ntitle: OpenWebUI Advanced Action\nauthor: Wes Caldwell\nemail: musicheardworldwide@gmail.com\nauthor_url: https://github.com/musicheardworldwide\nversion: 1.0.0\nlicense: MIT\ndescription: A structured Open WebUI action for data visualization, API integration, and real-time UI updates.\nrequirements:\n\"\"\"\n\nimport os\nimport json\nimport uuid\nimport logging\nimport time\nimport traceback\nfrom typing import Optional, Dict, Any\nfrom pydantic import BaseModel, Field\nfrom openai import OpenAI\nfrom fastapi import Request\nfrom open_webui.utils.misc import pop_system_message\nfrom open_webui.models.files import Files\n\n# Configure Logging\nlogger = logging.getLogger(__name__)\nif not logger.handlers:\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\n    logger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\n\n# Centralized Error Handling Function\ndef handle_error(exception: Exception, function_name: str, inputs: dict) -> dict:\n    \"\"\"\n    Handles errors and returns a structured response for OpenWebUI.\n\n    Args:\n        exception (Exception): The caught exception.\n        function_name (str): The name of the function where the error occurred.\n        inputs (dict): The original function inputs for debugging.\n\n    Returns:\n        dict: A structured error message to pass to OpenWebUI.\n    \"\"\"\n    error_message = str(exception)\n    stack_trace = traceback.format_exc()\n    logger.error(f\"Error in {function_name}: {error_message}\")\n    logger.debug(f\"Stack Trace:\\n{stack_trace}\")\n\n    return {\n        \"error\": True,\n        \"function\": function_name,\n        \"message\": error_message,\n        \"stack_trace\": stack_trace,\n        \"inputs\": inputs,\n        \"suggestion\": \"Check API configurations, file paths, and input values.\",\n    }\n\n\n# Action Definition\nclass Action:\n    \"\"\"\n    OpenWebUI Action function for data visualization and API integration.\n    \"\"\"\n\n    class Valves(BaseModel):\n        show_status: bool = Field(\n            default=True, description=\"Show status updates in UI.\"\n        )\n        html_filename: str = Field(\n            default=\"chart_visualization.html\",\n            description=\"Name of the generated HTML file.\",\n        )\n        OPENAI_KEY: str = Field(\n            default=\"\", description=\"API key for OpenAI or Claude integration.\"\n        )\n        OPENAI_URL: str = Field(\n            default=\"\", description=\"API endpoint for OpenAI or Claude service.\"\n        )\n\n    SYSTEM_PROMPT_BUILD_CHARTS = \"\"\"\n    Objective:\n    Your goal is to analyze the user's query, extract relevant data, and generate an appropriate chart.\n    \n    Steps:\n    1. Identify the data provided in the query.\n    2. Determine the best chart type (bar, pie, line, scatter, etc.).\n    3. Generate clean, well-structured HTML with embedded JavaScript (Plotly).\n    4. Ensure the chart scale is properly calibrated for readability.\n    5. If no chart can be generated, return a fun HTML message.\n\n    Constraints:\n    - Output **only** HTML (no extra text or markdown).\n    - Ensure numeric data is properly parsed and formatted.\n    - If the data is invalid, return a fun HTML error message.\n    \"\"\"\n\n    USER_PROMPT_GENERATE_HTML = \"\"\"\n    Given this user query: {Query}, generate the corresponding HTML with an embedded chart.\n    \"\"\"\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.openai = None\n        self.html_content = \"\"\n\n    def create_or_get_file(self, user_id: str, html_content: str) -> str:\n        \"\"\"\n        Creates or retrieves an HTML file for visualization.\n\n        Args:\n            user_id (str): The ID of the user.\n            html_content (str): The generated HTML content.\n\n        Returns:\n            str: The ID of the stored file.\n        \"\"\"\n        try:\n            filename = f\"{int(time.time() * 1000)}_{self.valves.html_filename}\"\n            directory = \"action_embed\"\n\n            logger.debug(f\"Checking existing files for user: {user_id}\")\n\n            # Check if the file already exists\n            existing_files = Files.get_files()\n            for file in existing_files:\n                if (\n                    file.filename == f\"{directory}/{user_id}/{filename}\"\n                    and file.user_id == user_id\n                ):\n                    logger.debug(f\"Existing file found. Updating content.\")\n                    self.update_html_content(file.meta[\"path\"], html_content)\n                    return file.id\n\n            # Create new file\n            base_path = os.path.join(\"uploads\", directory)\n            os.makedirs(base_path, exist_ok=True)\n            file_path = os.path.join(base_path, filename)\n\n            logger.debug(f\"Creating new file at: {file_path}\")\n            self.update_html_content(file_path, html_content)\n\n            file_id = str(uuid.uuid4())\n            meta = {\n                \"source\": file_path,\n                \"title\": \"Chart Visualization\",\n                \"content_type\": \"text/html\",\n                \"size\": os.path.getsize(file_path),\n                \"path\": file_path,\n            }\n\n            file_data = {\n                \"id\": file_id,\n                \"filename\": f\"{directory}/{user_id}/{filename}\",\n                \"meta\": meta,\n            }\n            new_file = Files.insert_new_file(user_id, file_data)\n            logger.debug(f\"New file created with ID: {new_file.id}\")\n            return new_file.id\n\n        except Exception as e:\n            return handle_error(\n                e,\n                \"create_or_get_file\",\n                {\"user_id\": user_id, \"html_content\": html_content},\n            )\n\n    def update_html_content(self, file_path: str, html_content: str):\n        \"\"\"\n        Updates or writes new HTML content to a file.\n\n        Args:\n            file_path (str): Path to the file.\n            html_content (str): The HTML content to write.\n        \"\"\"\n        try:\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(html_content)\n            logger.debug(f\"HTML content saved at: {file_path}\")\n\n        except Exception as e:\n            return handle_error(\n                e,\n                \"update_html_content\",\n                {\"file_path\": file_path, \"html_content\": html_content},\n            )\n\n    async def action(\n        self,\n        body: dict,\n        __user__=None,\n        __event_emitter__=None,\n        __event_call__=None,\n    ) -> Optional[dict]:\n        \"\"\"\n        Executes the action, generating a chart and embedding it into a response.\n\n        Args:\n            body (dict): Request payload.\n            __user__ (dict): User metadata.\n            __event_emitter__ (Callable): Emits status updates to the UI.\n\n        Returns:\n            dict: Updated request body with HTML embed tag.\n        \"\"\"\n        try:\n            logger.info(\"Action started: Generating visualization\")\n\n            if __event_emitter__:\n                await __event_emitter__(\n                    {\n                        \"type\": \"status\",\n                        \"data\": {\"description\": \"Analyzing data...\", \"done\": False},\n                    }\n                )\n\n            original_content = body[\"messages\"][-1][\"content\"]\n            self.openai = OpenAI(\n                api_key=self.valves.OPENAI_KEY, base_url=self.valves.OPENAI_URL\n            )\n\n            response = self.openai.chat.completions.create(\n                model=\"gpt-4-turbo\",\n                messages=[\n                    {\"role\": \"system\", \"content\": self.SYSTEM_PROMPT_BUILD_CHARTS},\n                    {\n                        \"role\": \"user\",\n                        \"content\": self.USER_PROMPT_GENERATE_HTML.format(\n                            Query=original_content\n                        ),\n                    },\n                ],\n                max_tokens=1000,\n                temperature=0.7,\n            )\n\n            html_content = response.choices[0].message.content\n            user_id = __user__[\"id\"]\n            file_id = self.create_or_get_file(user_id, html_content)\n\n            body[\"messages\"][-1][\"content\"] += f\"\\n\\n{{{{HTML_FILE_ID_{file_id}}}}}\"\n\n            await __event_emitter__(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\"description\": \"Chart ready!\", \"done\": True},\n                }\n            )\n            logger.info(\"Action completed successfully\")\n\n        except Exception as e:\n            return handle_error(e, \"action\", body)\n\n        return body\n",
        "meta": {
            "description": "example action template filter",
            "manifest": {
                "title": "OpenWebUI Advanced Action",
                "author": "Wes Caldwell",
                "email": "musicheardworldwide@gmail.com",
                "author_url": "https://github.com/musicheardworldwide",
                "version": "1.0.0",
                "license": "MIT",
                "description": "A structured Open WebUI action for data visualization, API integration, and real-time UI updates.",
                "requirements": ""
            }
        },
        "is_active": false,
        "is_global": false,
        "updated_at": 1741783170,
        "created_at": 1741783170
    }
]