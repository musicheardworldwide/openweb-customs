[
    {
        "id": "pipe_function_filter_example",
        "user_id": "06dbe545-cdc6-43ea-bec6-16d732ad95d7",
        "name": "pipe function filter example",
        "type": "pipe",
        "content": "\"\"\"\ntitle: OpenWebUI Advanced Pipe\nauthor: Wes Caldwell\nemail: musicheardworldwide@gmail.com\nauthor_url: https://github.com/musicheardworldwide\nversion: 1.0.0\nlicense: MIT\ndescription: A structured Open WebUI pipe for API integration, with streaming and advanced error handling.\nrequirements:\n\"\"\"\n\nimport os\nimport json\nimport logging\nimport requests\nimport time\nimport traceback\nfrom typing import Optional, Dict, Generator, Union, Iterator\nfrom pydantic import BaseModel, Field\nfrom fastapi import Request\nfrom open_webui.utils.misc import pop_system_message\n\n# Configure Logging\nlogger = logging.getLogger(__name__)\nif not logger.handlers:\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\n    logger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\n\n# Centralized Error Handling Function\ndef handle_error(exception: Exception, function_name: str, inputs: dict) -> dict:\n    \"\"\"\n    Handles errors and returns a structured response for OpenWebUI.\n\n    Args:\n        exception (Exception): The caught exception.\n        function_name (str): The name of the function where the error occurred.\n        inputs (dict): The original function inputs for debugging.\n\n    Returns:\n        dict: A structured error message to pass to OpenWebUI.\n    \"\"\"\n    error_message = str(exception)\n    stack_trace = traceback.format_exc()\n    logger.error(f\"Error in {function_name}: {error_message}\")\n    logger.debug(f\"Stack Trace:\\n{stack_trace}\")\n\n    return {\n        \"error\": True,\n        \"function\": function_name,\n        \"message\": error_message,\n        \"stack_trace\": stack_trace,\n        \"inputs\": inputs,\n        \"suggestion\": \"Check API configurations, input values, and connection settings.\",\n    }\n\n\n# Pipe Definition\nclass Pipe:\n    \"\"\"\n    OpenWebUI Pipe function for API integration, streaming responses, and structured processing.\n    \"\"\"\n\n    class Config(BaseModel):\n        API_ENDPOINT: str = Field(\n            default=\"https://api.example.com/process\",\n            description=\"External API endpoint for processing queries\",\n        )\n        API_KEY: str = Field(default=\"\", description=\"API key for authentication\")\n        MAX_IMAGE_SIZE: int = Field(\n            default=5 * 1024 * 1024, description=\"Maximum image size allowed (5MB)\"\n        )\n\n    def __init__(self):\n        self.config = self.Config()\n\n    def pipe(self, body: Dict) -> Union[str, Generator, Iterator]:\n        \"\"\"\n        Processes the request payload, modifying the message structure and calling an external API.\n\n        Args:\n            body (Dict): The OpenWebUI request payload.\n\n        Returns:\n            Union[str, Generator, Iterator]: The response, either as a string or a stream.\n        \"\"\"\n        try:\n            system_message, messages = pop_system_message(body[\"messages\"])\n            processed_messages = []\n\n            for message in messages:\n                processed_content = []\n                if isinstance(message.get(\"content\"), list):\n                    for item in message[\"content\"]:\n                        if item[\"type\"] == \"text\":\n                            processed_content.append(\n                                {\"type\": \"text\", \"text\": item[\"text\"]}\n                            )\n                        elif item[\"type\"] == \"image_url\":\n                            processed_image = self.process_image(item)\n                            processed_content.append(processed_image)\n                else:\n                    processed_content = [\n                        {\"type\": \"text\", \"text\": message.get(\"content\", \"\")}\n                    ]\n\n                processed_messages.append(\n                    {\"role\": message[\"role\"], \"content\": processed_content}\n                )\n\n            payload = {\n                \"model\": body[\"model\"],\n                \"messages\": processed_messages,\n                \"max_tokens\": body.get(\"max_tokens\", 1024),\n                \"temperature\": body.get(\"temperature\", 0.7),\n                \"top_p\": body.get(\"top_p\", 0.9),\n                \"stream\": body.get(\"stream\", False),\n                **({\"system\": str(system_message)} if system_message else {}),\n            }\n\n            headers = {\n                \"Authorization\": f\"Bearer {self.config.API_KEY}\",\n                \"Content-Type\": \"application/json\",\n            }\n\n            url = self.config.API_ENDPOINT\n\n            if body.get(\"stream\", False):\n                return self.stream_response(url, headers, payload)\n            else:\n                return self.non_stream_response(url, headers, payload)\n\n        except Exception as e:\n            return handle_error(e, \"pipe\", body)\n\n    def process_image(self, image_data: Dict) -> Dict:\n        \"\"\"\n        Processes image data, ensuring it meets size requirements.\n\n        Args:\n            image_data (Dict): Image metadata from the OpenWebUI request.\n\n        Returns:\n            Dict: Processed image data.\n        \"\"\"\n        try:\n            if image_data[\"image_url\"][\"url\"].startswith(\"data:image\"):\n                mime_type, base64_data = image_data[\"image_url\"][\"url\"].split(\",\", 1)\n                media_type = mime_type.split(\":\")[1].split(\";\")[0]\n                image_size = len(base64_data) * 3 / 4  # Convert base64 size to bytes\n\n                if image_size > self.config.MAX_IMAGE_SIZE:\n                    raise ValueError(\n                        f\"Image exceeds 5MB limit: {image_size / (1024 * 1024):.2f}MB\"\n                    )\n\n                return {\n                    \"type\": \"image\",\n                    \"source\": {\n                        \"type\": \"base64\",\n                        \"media_type\": media_type,\n                        \"data\": base64_data,\n                    },\n                }\n            else:\n                url = image_data[\"image_url\"][\"url\"]\n                response = requests.head(url, allow_redirects=True)\n                content_length = int(response.headers.get(\"content-length\", 0))\n\n                if content_length > self.config.MAX_IMAGE_SIZE:\n                    raise ValueError(\n                        f\"Image at URL exceeds 5MB limit: {content_length / (1024 * 1024):.2f}MB\"\n                    )\n\n                return {\"type\": \"image\", \"source\": {\"type\": \"url\", \"url\": url}}\n\n        except Exception as e:\n            return handle_error(e, \"process_image\", image_data)\n\n    def stream_response(self, url: str, headers: Dict, payload: Dict) -> Generator:\n        \"\"\"\n        Handles streaming responses from the API.\n\n        Args:\n            url (str): The API endpoint.\n            headers (Dict): Request headers.\n            payload (Dict): Request body.\n\n        Returns:\n            Generator: Streamed API response.\n        \"\"\"\n        try:\n            with requests.post(\n                url, headers=headers, json=payload, stream=True, timeout=(3.05, 60)\n            ) as response:\n                if response.status_code != 200:\n                    raise Exception(\n                        f\"HTTP Error {response.status_code}: {response.text}\"\n                    )\n\n                for line in response.iter_lines():\n                    if line:\n                        yield line.decode(\"utf-8\")\n\n        except Exception as e:\n            yield handle_error(e, \"stream_response\", payload)\n\n    def non_stream_response(self, url: str, headers: Dict, payload: Dict) -> str:\n        \"\"\"\n        Handles non-streaming API responses.\n\n        Args:\n            url (str): The API endpoint.\n            headers (Dict): Request headers.\n            payload (Dict): Request body.\n\n        Returns:\n            str: The response as a string.\n        \"\"\"\n        try:\n            response = requests.post(\n                url, headers=headers, json=payload, timeout=(3.05, 60)\n            )\n            if response.status_code != 200:\n                raise Exception(f\"HTTP Error {response.status_code}: {response.text}\")\n\n            return response.json().get(\"response\", \"No response received.\")\n\n        except Exception as e:\n            return handle_error(e, \"non_stream_response\", payload)\n\n\n# Example Usage\nif __name__ == \"__main__\":\n    pipe = Pipe()\n\n    async def test_pipe():\n        test_request = {\n            \"messages\": [{\"role\": \"user\", \"content\": \"What is Open WebUI?\"}]\n        }\n\n        response = pipe.pipe(test_request)\n        if isinstance(response, Generator):\n            for chunk in response:\n                print(chunk)\n        else:\n            print(response)\n\n    import asyncio\n\n    asyncio.run(test_pipe())\n",
        "meta": {
            "description": "pipe function filter example",
            "manifest": {
                "title": "OpenWebUI Advanced Pipe",
                "author": "Wes Caldwell",
                "email": "musicheardworldwide@gmail.com",
                "author_url": "https://github.com/musicheardworldwide",
                "version": "1.0.0",
                "license": "MIT",
                "description": "A structured Open WebUI pipe for API integration, with streaming and advanced error handling.",
                "requirements": ""
            }
        },
        "is_active": false,
        "is_global": false,
        "updated_at": 1741783131,
        "created_at": 1741783131
    }
]